import { useState, useCallback } from 'react'
import { debounce } from 'lodash'
import { useGLTF, useEnvironment, Text, DragControls } from '@react-three/drei'
import { Select } from '@react-three/postprocessing'
import * as THREE from 'three'
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 kitchen.glb --transform
Files: kitchen.glb [134.46MB] > kitchen-transformed.glb [2.1MB] (98%)
*/
interface SceneProps {
  rotation: number[]
  position: number[]
  grp: THREE.Group<THREE.Object3DEventMap>
}
export default function Scene({ rotation, position, grp }: SceneProps) {
  // Load model
  // const { nodes, materials } = useGLTF('/kitchen-transformed.glb')
  // Load environment (using it only on the chairs, for reflections)
  console.log('Scene', grp)
  // const env = useEnvironment({ preset: 'city' })
  // Hover state
  const [hovered, hover] = useState(null)
  // Debounce hover a bit to stop the ticker from being erratic
  const debouncedHover = useCallback(debounce(hover, 30), [])
  const over = (name) => (e) => (e.stopPropagation(), debouncedHover(name))
  // Get the priced item
  console.log('Scene b4 return')
  const mesh: THREE.Mesh[] = grp.children as THREE.Mesh[]
  const handlePointerOver = (e) => {
    const mesh = e.object
    console.log('PointerOver', mesh.name)
  }
  const handlePointerOut = (e) => {
    const mesh = e.object
    console.log('PointerOut', mesh.name)
  }
  return (
    <>
      <group {...rotation}>
        {mesh.map((m) => (
          <mesh
            key={m.uuid}
            geometry={m.geometry}
            material={m.material}
            onPointerOver={handlePointerOver}
            onPointerOut={handlePointerOut}
          />
        ))}
      </group>
    </>
  )
}
